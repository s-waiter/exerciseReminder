# DeskCare CPU 性能优化报告

**日期**: 2026-02-02  
**作者**: Trae AI Assistant  
**版本**: 1.0

## 1. 背景与目标

用户在使用过程中观察到 DeskCare 程序存在较高的 CPU 占用情况：
*   **启动阶段**: 约 9% (持续较长时间)
*   **运行中期**: 约 5%-6%
*   **稳定后期**: 约 2%-3%

**目标**: 在保留核心视觉体验（“视觉优先”）的前提下，尽可能降低 CPU 占用，特别是程序在后台或最小化到托盘时的资源消耗，实现“前台极致视觉，后台零负担”。

## 2. 优化原则

本次优化遵循以下核心原则：
1.  **可见性驱动 (Visibility-Driven)**: 所有的动画、渲染、计算逻辑必须仅在 UI 可见时执行。
2.  **拒绝空转 (No Idle Spinning)**: 消除所有在后台默默运行但不产生视觉效果的逻辑（如隐藏状态下的旋转动画、Canvas 重绘请求）。
3.  **视觉权衡 (Visual Trade-off)**: 在不明显降低视觉质量的前提下，简化高昂的渲染特效（如实时动态模糊）；在视觉质量受损时（如圆角裁剪），果断回滚性能优化以保全体验。

## 3. 详细优化措施

### 3.1 粒子系统优化 (Main.qml)

粒子系统是 CPU 消耗大户，每一帧都需要计算数百个粒子的位置、透明度和生命周期。

*   **措施 1: 降低发射率与生命周期**
    *   `emitRate`: 从 8 降低至 4。
    *   `lifeSpan`: 从 4000ms 降低至 3000ms。
    *   **效果**: 显著减少了同屏存在的粒子总数，直接降低了每帧的遍历计算量。
*   **措施 2: 生命周期绑定**
    *   代码: `running: mainWindow.visible`
    *   **效果**: 当窗口隐藏（如最小化到托盘）时，粒子系统完全停止，不再消耗任何 CPU。

### 3.2 动态模糊优化 (Main.qml - RectangularGlow)

`RectangularGlow` 的 `glowRadius` 属性如果进行动画变化，会导致渲染引擎每帧重新计算高斯模糊核，这是极其昂贵的操作。

*   **措施**: 移除 `glowRadius` 的无限呼吸动画，改为仅在 `opacity` 上做呼吸动画，或仅在鼠标交互时改变模糊半径。
*   **效果**: 将每帧的“重算模糊”变为“纹理合成”，大幅降低 GPU/CPU 负载。
*   **补充**: 同样添加了 `visible: isPinned && timerEngine.statusText === "工作中"` 等精细的可见性控制。

### 3.3 Canvas 绘制优化 (Main.qml - ProgressRing)

Qt Quick 的 `Canvas` 是基于 CPU 或 GPU 的 2D 绘图上下文。频繁调用 `requestPaint()` 会触发昂贵的重绘流程。

*   **问题**: 即使窗口不可见，后端的 Timer 仍在更新进度，触发 `onProgressChanged` -> `requestPaint()`。
*   **措施**: 添加“视觉守卫”。
    ```qml
    onProgressChanged: if (mainWindow.visible) requestPaint()
    ```
    同时利用 `Connections` 监听 `onVisibleChanged`，确保窗口再次显示时立即刷新一帧。
*   **效果**: 彻底消除了后台运行时的绘图指令开销。

### 3.4 动画生命周期管理 (OverlayWindow.qml)

全屏提醒界面中存在装饰性的旋转动画。

*   **问题**: `RotationAnimation` 默认为 `Infinite` 循环，即使 `OverlayWindow` 隐藏，该动画对象仍在后台计算属性值。
*   **措施**: 显式绑定 `running` 属性。
    ```qml
    RotationAnimation on rotation {
        running: overlayWin.visible // 仅可见时运行
        // ...
    }
    ```
*   **效果**: 确保提醒窗口关闭后，后台无任何残留动画逻辑。

### 3.5 视觉与性能的权衡 (OpacityMask vs Clip)

*   **尝试**: 为了消除 `OpacityMask` 带来的离屏渲染成本，曾尝试使用 `Rectangle` 的 `clip: true`。
*   **问题**: `clip: true` 只能进行矩形裁剪，导致圆形悬浮球出现方形轮廓（四个圆角被切断）。
*   **决策**: **回滚优化**。恢复 `OpacityMask`。
*   **理由**: 用户明确指示“如果视觉体验和性能必须二选一，毫不犹豫选择视觉体验”。虽然牺牲了一点点渲染性能，但保证了完美的 UI 呈现。

## 4. 最终成效

经过上述优化，程序的性能模型如下：

| 状态 | 视觉子系统 | 动画/粒子 | 重绘请求 | 预估 CPU 占用 |
| :--- | :--- | :--- | :--- | :--- |
| **托盘后台** | **全停** | 停止 | 无 | **< 0.1%** (仅核心计时器) |
| **前台运行** | **全开** | 优化后运行 | 按需 | 正常水平 (大幅优于优化前) |

## 5. 后续建议

*   **持续监控**: 建议用户在长时间运行后再次观察任务管理器，确认是否存在内存泄漏（虽然 QML 自动回收，但频繁创建对象仍需留意）。
*   **GPU 辅助**: 当前主要依赖 CPU 逻辑优化，未来可考虑将更多视觉效果迁移至 ShaderEffect (GLSL) 以进一步释放 CPU。

---
*文档生成时间: 2026-02-02 14:35*
