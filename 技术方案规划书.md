# 久坐提醒助手 - 技术方案规划书 (Qt 5 版)

## 1. 技术选型 (Tech Stack)

鉴于您当前的开发环境，本项目将基于 **Qt 5** 进行适配，同时保持高性能和现代化的开发标准。

*   **编程语言**: **C++ 17** (或 C++ 14)
    *   *选择理由*:
        *   **兼容性**: Qt 5.15 对 C++ 17 支持良好 (需配合较新的编译器如 MSVC 2019+)。
        *   **高性能**: 依然满足“极低资源占用”的核心需求。
        *   **底层控制**: 方便调用 Windows API (User32.dll, Kernel32.dll) 实现系统级功能。

*   **GUI 框架**: **Qt 5.15 LTS**
    *   *选择理由*: Qt 5 系列中最成熟、稳定的版本，拥有庞大的社区资源和文档支持。

*   **UI 渲染技术**: **Qt Quick 2 (QML)**
    *   *选择理由*:
        *   **流畅体验**: 相比 QWidget，Qt Quick 在 Qt 5 中依然是实现动态、流畅 UI 的最佳选择。
        *   **硬件加速**: 利用 GPU 加速渲染，降低 CPU 负担。
        *   **注意事项**: 需在代码中显式开启 High DPI Scaling 以适配高分屏。

*   **构建系统**: **CMake** (或 qmake)
    *   *选择理由*: 虽然 qmake 在 Qt 5 时代很流行，但推荐使用 CMake 以保持与现代 C++ 生态的接轨，便于未来迁移或集成第三方库。

---

## 2. 系统架构 (Architecture)

架构保持 **MVVM (Model-View-ViewModel)** 模式不变，这是 Qt Quick 应用的最佳实践。

### 2.1 架构分层
1.  **Model (业务逻辑层 - C++)**:
    *   负责核心数据的处理（计时、配置、系统API）。
    *   完全独立于 Qt GUI 模块，仅依赖 Qt Core。
2.  **View (视图层 - QML)**:
    *   使用 Qt Quick 2.x 模块。
    *   负责界面展示和动画效果（使用 `import QtQuick 2.15` 等）。
3.  **ViewModel (适配层 - C++)**:
    *   继承自 `QObject`。
    *   通过 `Q_PROPERTY` 绑定数据。
    *   通过 `QQmlContext` 或 `qmlRegisterType` 注入到 QML 环境中。

---

## 3. 核心模块设计

### 3.1 核心控制器 (CoreController)
*   **职责**: 应用程序入口，单例模式。
*   **Qt 5 特殊处理**:
    *   需要在 `QPolyGuiApplication` 实例化之前调用 `QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);` 确保在高分屏下显示正常。

### 3.2 计时与状态引擎 (TimerEngine)
*   **职责**: 管理倒计时状态机 (Working -> Reminding -> Snoozing -> Paused)。
*   **实现**: 使用 `QTimer` 或 `QElapsedTimer` (更推荐，防系统时间修改) 进行计时。

### 3.3 界面管理器 (WindowManager)
*   **职责**: 管理 QML 窗口加载。
*   **实现**:
    *   使用 `QQmlApplicationEngine` 加载 QML 文件。
    *   **全屏方案**: 设置 `flags: Qt.Window | Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint`。
    *   **多屏支持**: 遍历 `QGuiApplication::screens()` 确保窗口覆盖所有屏幕。

### 3.4 系统集成模块 (SystemIntegrator)
*   **托盘图标**: 使用 `QSystemTrayIcon` (QWidget 模块或纯 QML 实现较麻烦，通常建议 C++ 端实现托盘逻辑)。
*   **开机自启**: 使用 `QSettings` 读写注册表 `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`。

### 3.5 在线更新系统 (Online Updater)
*   **需求**: **零打扰 (Zero Disturbance)** 自动更新。
*   **流程**:
    1.  **静默检查**: 程序启动时后台通过 HTTP 请求检查远程 `version.json`。
    2.  **视觉提示**:
        *   **有新版本**: 主界面“刷新/设置”图标开始呼吸闪烁 (Opacity Animation)。
        *   **无新版本**: 图标保持静止。
    3.  **用户交互**:
        *   **点击无更新**: Toast 提示“已是最新”。
        *   **点击有更新**: 弹出 `UpdateDialog` (半透明毛玻璃风格)，显示更新日志，询问是否更新。
    4.  **更新执行**:
        *   用户确认后，主界面显示下载进度。
        *   下载完成后，启动独立的 `Updater.exe`，关闭主程序，解压覆盖，重启主程序。

### 3.6 用户活跃度统计 (DAU Analytics)
*   **需求**: 统计每日活跃用户 (DAU)，包括 IP 和 Mac 地址（脱敏）。
*   **实现方案**: **GoAccess 日志分析集成 (无需独立后端)**。
*   **原理**: 利用现有的 Web 服务器日志分析系统 (GoAccess)，客户端发送特定格式的 HTTP GET 请求，服务器 Nginx 记录日志，GoAccess 自动统计。
*   **客户端实现 (C++)**:
    1.  **设备指纹**: 获取主网卡 MAC 地址，计算 `UniqueId = SHA256(MAC + "DeskCare_Salt")`。
    2.  **上报时机**: 每日首次启动后延时 15 秒。
    3.  **上报请求**:
        ```http
        GET http://47.101.52.0/api/report?uid={hashed_uid}&ver={version}&app=DeskCare
        User-Agent: DeskCare-Client/1.0
        ```
*   **服务端实现 (现有架构)**:
    *   **Nginx**: 记录访问日志 `access.log`。
    *   **GoAccess**: 定时分析日志，生成可视化报表 `http://47.101.52.0/stats/report.html`。
    *   **数据解读 (重要)**:
        *   **总览面板**: 显示的是服务器**所有**流量（含官网访问、资源加载、文件下载等），**不能**直接作为 DAU。
        *   **正确查看方式**: 在 **"请求的文件 (Request Files)"** 列表中找到路径 `/api/report`。
            *   该行的 **Hits** = 软件启动次数
            *   该行的 **Visitors** = 每日活跃用户数 (DAU)
    *   **进阶方案 (生成纯净报表)**:
        *   建议在服务端使用 grep 过滤日志，生成专属报表：
            ```bash
            grep "/api/report" /var/log/nginx/access.log | goaccess - -o /var/www/html/stats/deskcare_report.html --log-format=COMBINED
            ```
        *   访问新地址 `.../stats/deskcare_report.html` 即可看到纯净的软件活跃数据。
    *   **报表更新频率 (推荐配置)**:
        *   当前报表为静态 HTML，需配置服务器定时任务 (Crontab) 进行更新。
        *   **建议配置**: 每 10 分钟更新一次，以获得近乎实时的体验。
        *   `crontab -e` 示例:
            ```bash
            */10 * * * * goaccess /var/log/nginx/access.log -o /var/www/html/stats/report.html --log-format=COMBINED
            ```

---

## 4. 数据结构与配置

### 4.1 配置文件 (config.json)
```json
{
  "general": {
    "autoStart": true,
    "intervalMinutes": 45,
    "snoozeMinutes": 5
  },
  "ui": {
    "theme": "dark",
    "backgroundSource": "default"
  }
}
```

---

## 5. 项目目录结构规划

```
ExerciseReminder/
├── CMakeLists.txt              # 构建脚本 (适配 Qt5)
├── assets/                     # 资源文件
│   ├── images/
│   ├── sounds/
│   └── qml/
│       ├── Main.qml
│       ├── OverlayWindow.qml   # 全屏提醒层
│       └── components/         # 自定义组件
├── src/
│   ├── main.cpp                # 入口 (含 High DPI 设置)
│   ├── core/
│   │   ├── TimerEngine.h/cpp
│   │   ├── ConfigManager.h/cpp
│   │   ├── UpdateManager.h/cpp # 自动更新逻辑
│   │   └── StatisticsManager.h/cpp # 用户统计逻辑
│   ├── gui/
│   │   ├── AppViewModel.h/cpp
│   │   └── TrayIcon.h/cpp      # C++ 实现的托盘
│   └── utils/
└── tests/
```

---

## 6. 开发路线图 (Roadmap - Qt 5)

1.  **Phase 1: 环境与基础**
    *   配置 CMake 查找 `Qt5::Core`, `Qt5::Gui`, `Qt5::Qml`, `Qt5::Quick`, `Qt5::Widgets` (用于托盘)。
    *   编写 `main.cpp`，开启 High DPI 支持，加载空的 QML 窗口。

2.  **Phase 2: 核心逻辑与托盘**
    *   实现 C++ 端的计时器逻辑。
    *   实现 `QSystemTrayIcon`，确保托盘菜单能正常弹出和响应。

3.  **Phase 3: QML 全屏界面**
    *   编写 `OverlayWindow.qml`，使用 Qt Quick 2 的动画系统 (`NumberAnimation`, `SequentialAnimation`) 实现柔和的弹出效果。
    *   实现 C++ 与 QML 的信号槽连接。

4.  **Phase 4: 系统能力集成**
    *   实现注册表开机自启。
    *   完善配置持久化。
    *   打包发布 (使用 `windeployqt` 工具)。

5.  **Phase 5: 增值服务 (New)**
    *   集成 `UpdateManager` 实现静默更新检查与下载。
    *   集成 `StatisticsManager` 实现隐私合规的 DAU 统计上报。
